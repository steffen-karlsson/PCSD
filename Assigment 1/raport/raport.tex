\documentclass[10pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}
\newcommand{\folge}[1]{\left \lbrace #1 \right \rbrace }
\lstset{language=Java, numbers=left, numberstyle=\footnotesize}
\author{Thorbj√∏rn Christensen \\
Steffen Karlsson \\
Kai Ejler Rasmussen}
\title{Principles of Computer System Design - Assignment 1}
\begin{document}
\maketitle

\section*{Exercises}
\subsection*{Question 1: Fundamental Abstractions}
\begin{enumerate}
	\item 
	We split the address used in READ and WRITE into a group of X least significant bits and a group of $Bits_{max}-X$ bits. The most significant group will refer to a machine using a name resolution service, in the client, and the least significant group will refer to a memory address on the specified server. Each server is added sequentially in the bit domain to allow for a sequential memory domain. The scalability of this solution depends on the distribution between the two groups in the naming. A possible distribution in a 64 bit domain could be $2^{56_{bits}}$ memory addresses and $2^{8_{bits}}$ possible machines. 
	
	This design, if configured correctly, will automatically change server when the address rolls over in the most significant group.
	
	
	\item The READ and WRITE API are both using a name resolution service (ie. lookup table or other service) to resolve the ip of the receiving server. The value is then read or written using RPC.
	\\
\begin{lstlisting}
READ(name)
  ip <- lookupServer(name & SERVER_BITMASK)
  memory <- name & MEMORY_BITMASK
  return getValueFromServer(ip, memory)
\end{lstlisting}	

\begin{lstlisting}
WRITE(name,value)
  ip <- lookupServer(name & SERVER_BITMASK)
  memory <- name & MEMORY_BITMASK
  writeValueToServer(ip, memory, value)
\end{lstlisting}
	
	\item The READ/WRITE API of the abstraction layer should be atomic to keep consistency, since generic READ/WRITE operations are atomic. To achieve this, a lock is obtained during the operations on the remote machine.
	
	\item The design allows for dynamic joins and leaves as long as the sequence is intact. If the servers 1,2 and 3 is available, a fourth server can be added as 00000100 (big-endian) in a byte to allow for roll over. The design does, however, not allow for serves to be added or removed out of sequence. For example removing server 2 gives the invalid sequence $1,3,4$. To accommodate for this, a centralized service layer could be added to reallocate memory addresses to similar to how bad blocks are reallocated on persistent storage.
	
	
\end{enumerate}

\subsection*{Question 2: Techniques for Performance}
\begin{enumerate}
	\item 
	
	
	\item
	\item
	Looking up in the cache before forwarding the request to be evaluated, if the cache was insufficient, is a fast path optimization. 	
	
\end{enumerate}

\section*{Questions for Discussion on Architecture}

\end{document}

